---
phase: 02-core-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/http.ts
  - tests/http.test.ts
  - package.json
  - package-lock.json
autonomous: true

must_haves:
  truths:
    - "HTTP wrapper throws typed errors for non-2xx responses"
    - "Retry logic retries transient failures (429, 5xx) with exponential backoff"
    - "Request timeout cancels after configured duration"
    - "Network errors are retried"
  artifacts:
    - path: "src/http.ts"
      provides: "Low-level fetch wrapper with retry logic"
      exports: ["request", "requestWithRetry"]
      min_lines: 80
    - path: "tests/http.test.ts"
      provides: "HTTP wrapper tests"
      min_lines: 100
  key_links:
    - from: "src/http.ts"
      to: "src/errors.ts"
      via: "import createErrorFromResponse"
      pattern: "import.*createErrorFromResponse.*from.*errors"
    - from: "src/http.ts"
      to: "exponential-backoff"
      via: "backOff import"
      pattern: "import.*backOff.*from.*exponential-backoff"
---

<objective>
Build the low-level HTTP wrapper with retry logic for transient failures.

Purpose: Provides the fetch abstraction layer that the AgentOSClient will use. Handles response parsing, error classification, timeout management, and automatic retry with exponential backoff.

Output:
- src/http.ts with request() and requestWithRetry() functions
- tests/http.test.ts with mocked fetch tests
- exponential-backoff package installed
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-infrastructure/02-RESEARCH.md

# Dependencies from Plan 02-01
@src/errors.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install exponential-backoff package</name>
  <files>package.json, package-lock.json</files>
  <action>
Install the exponential-backoff package as a production dependency:

```bash
npm install exponential-backoff
```

This package is only 2KB with zero dependencies. It handles:
- Configurable retry attempts
- Exponential delay calculation
- Jitter to prevent thundering herd
- Custom retry condition functions

Per RESEARCH.md, this is preferred over hand-rolling retry logic because it handles edge cases correctly.
  </action>
  <verify>Run `npm ls exponential-backoff` - should show version 3.x installed</verify>
  <done>exponential-backoff is listed in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP wrapper with retry logic</name>
  <files>src/http.ts, tests/http.test.ts</files>
  <action>
Create src/http.ts with the following functions:

**1. parseErrorBody(response: Response): Promise<string>**
- Try to parse response as JSON
- Extract message from common formats: `{ message }`, `{ error }`, `{ error: { message } }`, `{ detail }`
- Fall back to response.text() if JSON parsing fails
- Fall back to response.statusText if text fails

**2. request<T>(url: string, options: RequestOptions = {}): Promise<T>**
- Perform fetch with provided options
- Extract x-request-id header from response
- If !response.ok: parse error body and throw typed error via createErrorFromResponse
- Handle 204 No Content (return undefined as T)
- Parse and return JSON for success responses

**3. requestWithRetry<T>(url: string, options: RequestOptions, maxRetries: number, timeoutMs: number): Promise<T>**
- Use AbortSignal.timeout(timeoutMs) for request timeout
- Wrap request() in backOff() from exponential-backoff
- Configure retry:
  - numOfAttempts: maxRetries + 1 (first attempt counts)
  - startingDelay: 500ms
  - timeMultiple: 2
  - maxDelay: 30000ms
  - jitter: 'full'
- Retry condition function:
  - Retry on RateLimitError (429)
  - Retry on status >= 500
  - Retry on TypeError (network failures)
  - Do NOT retry on 4xx client errors (except 429)
- Catch TimeoutError and throw APIError with status 0

Create tests/http.test.ts:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { request, requestWithRetry } from '../src/http';
import { APIError, BadRequestError, NotFoundError, InternalServerError } from '../src/errors';

// Mock global fetch
const mockFetch = vi.fn();
vi.stubGlobal('fetch', mockFetch);

describe('HTTP Module', () => {
  beforeEach(() => {
    mockFetch.mockReset();
  });

  describe('request', () => {
    it('should return JSON for successful response', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: () => Promise.resolve({ data: 'test' }),
        headers: new Headers(),
      });

      const result = await request<{ data: string }>('https://api.test.com/endpoint');
      expect(result).toEqual({ data: 'test' });
    });

    it('should handle 204 No Content', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 204,
        headers: new Headers(),
      });

      const result = await request<void>('https://api.test.com/endpoint');
      expect(result).toBeUndefined();
    });

    it('should throw BadRequestError for 400', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 400,
        json: () => Promise.resolve({ message: 'Invalid input' }),
        headers: new Headers({ 'x-request-id': 'req-123' }),
      });

      await expect(request('https://api.test.com/endpoint'))
        .rejects.toThrow(BadRequestError);
    });

    it('should throw NotFoundError for 404', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 404,
        json: () => Promise.resolve({ message: 'Not found' }),
        headers: new Headers(),
      });

      await expect(request('https://api.test.com/endpoint'))
        .rejects.toThrow(NotFoundError);
    });

    it('should include requestId in error', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        json: () => Promise.resolve({ message: 'Server error' }),
        headers: new Headers({ 'x-request-id': 'req-456' }),
      });

      try {
        await request('https://api.test.com/endpoint');
      } catch (error) {
        expect(error).toBeInstanceOf(InternalServerError);
        expect((error as APIError).requestId).toBe('req-456');
      }
    });

    it('should handle non-JSON error responses', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        json: () => Promise.reject(new Error('Not JSON')),
        text: () => Promise.resolve('Internal Server Error'),
        statusText: 'Internal Server Error',
        headers: new Headers(),
      });

      await expect(request('https://api.test.com/endpoint'))
        .rejects.toThrow(InternalServerError);
    });
  });

  describe('requestWithRetry', () => {
    it('should retry on 500 errors', async () => {
      mockFetch
        .mockResolvedValueOnce({
          ok: false,
          status: 500,
          json: () => Promise.resolve({ message: 'Server error' }),
          headers: new Headers(),
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: () => Promise.resolve({ data: 'success' }),
          headers: new Headers(),
        });

      const result = await requestWithRetry<{ data: string }>(
        'https://api.test.com/endpoint',
        {},
        2,
        5000
      );

      expect(result).toEqual({ data: 'success' });
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });

    it('should NOT retry on 400 errors', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        status: 400,
        json: () => Promise.resolve({ message: 'Bad request' }),
        headers: new Headers(),
      });

      await expect(
        requestWithRetry('https://api.test.com/endpoint', {}, 2, 5000)
      ).rejects.toThrow(BadRequestError);

      expect(mockFetch).toHaveBeenCalledTimes(1);
    });

    it('should retry on network errors', async () => {
      mockFetch
        .mockRejectedValueOnce(new TypeError('Network error'))
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: () => Promise.resolve({ data: 'recovered' }),
          headers: new Headers(),
        });

      const result = await requestWithRetry<{ data: string }>(
        'https://api.test.com/endpoint',
        {},
        2,
        5000
      );

      expect(result).toEqual({ data: 'recovered' });
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });
  });
});
```

IMPORTANT: Use vi.stubGlobal for mocking fetch, not vi.mock. This works better with native fetch.
  </action>
  <verify>Run `npm run test` - all HTTP tests pass. Run `npm run lint` - no errors. Run `npm run typecheck` - no errors.</verify>
  <done>http.ts exports request and requestWithRetry. Tests verify error handling, retry logic, and timeout behavior.</done>
</task>

</tasks>

<verification>
Run the complete validation pipeline:

```bash
npm run build && npm run test && npm run lint && npm run typecheck
```

All commands should pass. Verify retry behavior in test output.
</verification>

<success_criteria>
- [ ] exponential-backoff is in package.json dependencies
- [ ] src/http.ts exists with request() and requestWithRetry() functions
- [ ] tests/http.test.ts has tests for success, errors, retry, and timeout
- [ ] HTTP wrapper throws typed errors (verified by tests)
- [ ] Retry logic only retries transient failures (429, 5xx, network)
- [ ] `npm run test` passes with all HTTP tests green
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-infrastructure/02-02-SUMMARY.md`
</output>
