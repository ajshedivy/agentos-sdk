---
phase: 02-core-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/errors.ts
  - tests/errors.test.ts
autonomous: true

must_haves:
  truths:
    - "Error classes can be caught with instanceof checks"
    - "Error classes contain status code, message, and requestId"
    - "TypeScript interfaces define client options and request types"
  artifacts:
    - path: "src/types.ts"
      provides: "AgentOSClientOptions, RequestOptions, OSConfig, HealthStatus interfaces"
      exports: ["AgentOSClientOptions", "RequestOptions", "OSConfig", "HealthStatus"]
    - path: "src/errors.ts"
      provides: "Typed error class hierarchy"
      exports: ["APIError", "BadRequestError", "AuthenticationError", "NotFoundError", "UnprocessableEntityError", "RateLimitError", "InternalServerError", "RemoteServerUnavailableError"]
    - path: "tests/errors.test.ts"
      provides: "Error class tests"
      min_lines: 50
  key_links:
    - from: "src/errors.ts"
      to: "Object.setPrototypeOf"
      via: "prototype chain fix"
      pattern: "Object\\.setPrototypeOf\\(this"
---

<objective>
Create the foundational type definitions and error class hierarchy for the AgentOS SDK.

Purpose: Establishes the type system and error handling infrastructure that all subsequent SDK code depends on. Error classes enable typed catch blocks; interfaces define the public API contract.

Output:
- src/types.ts with AgentOSClientOptions, RequestOptions, OSConfig, HealthStatus
- src/errors.ts with complete error class hierarchy (APIError + 7 specific error types)
- tests/errors.test.ts validating instanceof behavior
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-infrastructure/02-RESEARCH.md

# Existing code structure
@src/index.ts
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript type definitions</name>
  <files>src/types.ts</files>
  <action>
Create src/types.ts with the following interfaces:

```typescript
/**
 * Configuration options for the AgentOSClient
 */
export interface AgentOSClientOptions {
  /**
   * Base URL for the AgentOS API (required)
   * @example "https://api.agentos.example.com"
   */
  baseUrl: string;

  /**
   * API key for Bearer token authentication (optional)
   * Can also be provided per-request via headers
   */
  apiKey?: string;

  /**
   * Request timeout in milliseconds
   * @default 30000 (30 seconds)
   */
  timeout?: number;

  /**
   * Maximum number of retry attempts for transient failures
   * @default 2
   */
  maxRetries?: number;

  /**
   * Additional headers to include in all requests
   */
  headers?: Record<string, string>;
}

/**
 * Internal request options for HTTP calls
 */
export interface RequestOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  body?: unknown;
  headers?: Record<string, string>;
  signal?: AbortSignal;
}

/**
 * OS configuration response from /config endpoint
 */
export interface OSConfig {
  version: string;
  environment: string;
  features: Record<string, boolean>;
}

/**
 * Health status response from /health endpoint
 */
export interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  details?: Record<string, unknown>;
}
```

Note: These interfaces match the patterns from RESEARCH.md. OSConfig and HealthStatus are placeholder shapes - they will be refined in Phase 3 when we have OpenAPI types.
  </action>
  <verify>Run `npm run typecheck` - should pass with no errors</verify>
  <done>types.ts exports AgentOSClientOptions, RequestOptions, OSConfig, HealthStatus interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Create error class hierarchy with tests</name>
  <files>src/errors.ts, tests/errors.test.ts</files>
  <action>
Create src/errors.ts with the complete error class hierarchy from RESEARCH.md:

1. **Base APIError class:**
   - Properties: status (number), message (string), requestId (optional string), headers (optional Record)
   - CRITICAL: Include `Object.setPrototypeOf(this, APIError.prototype)` after super() call
   - This fixes instanceof checks when TypeScript compiles to ES5

2. **Specific error subclasses** (each with Object.setPrototypeOf fix):
   - BadRequestError (400)
   - AuthenticationError (401)
   - NotFoundError (404)
   - UnprocessableEntityError (422)
   - RateLimitError (429)
   - InternalServerError (500)
   - RemoteServerUnavailableError (503)

3. **Helper function** for creating errors from HTTP responses:
   - `createErrorFromResponse(status: number, message: string, requestId?: string, headers?: Record<string, string>): APIError`
   - Switch on status code to return appropriate error subclass
   - Default to generic APIError for unrecognized status codes

Create tests/errors.test.ts:

```typescript
import { describe, it, expect } from 'vitest';
import {
  APIError,
  BadRequestError,
  AuthenticationError,
  NotFoundError,
  UnprocessableEntityError,
  RateLimitError,
  InternalServerError,
  RemoteServerUnavailableError,
  createErrorFromResponse,
} from '../src/errors';

describe('Error Classes', () => {
  describe('APIError', () => {
    it('should have correct properties', () => {
      const error = new APIError(500, 'Server error', 'req-123');
      expect(error.status).toBe(500);
      expect(error.message).toBe('Server error');
      expect(error.requestId).toBe('req-123');
      expect(error.name).toBe('APIError');
    });

    it('should work with instanceof', () => {
      const error = new APIError(500, 'test');
      expect(error instanceof APIError).toBe(true);
      expect(error instanceof Error).toBe(true);
    });
  });

  describe('BadRequestError', () => {
    it('should have status 400', () => {
      const error = new BadRequestError('Invalid input');
      expect(error.status).toBe(400);
      expect(error instanceof BadRequestError).toBe(true);
      expect(error instanceof APIError).toBe(true);
    });
  });

  // Similar tests for each error type...

  describe('createErrorFromResponse', () => {
    it('should create BadRequestError for 400', () => {
      const error = createErrorFromResponse(400, 'Bad request');
      expect(error instanceof BadRequestError).toBe(true);
    });

    it('should create AuthenticationError for 401', () => {
      const error = createErrorFromResponse(401, 'Unauthorized');
      expect(error instanceof AuthenticationError).toBe(true);
    });

    it('should create NotFoundError for 404', () => {
      const error = createErrorFromResponse(404, 'Not found');
      expect(error instanceof NotFoundError).toBe(true);
    });

    it('should create InternalServerError for 5xx', () => {
      const error = createErrorFromResponse(502, 'Bad gateway');
      expect(error instanceof InternalServerError).toBe(true);
    });

    it('should create generic APIError for unknown status', () => {
      const error = createErrorFromResponse(418, 'I am a teapot');
      expect(error instanceof APIError).toBe(true);
      expect(error.constructor.name).toBe('APIError');
    });
  });
});
```

Write tests for ALL error types to ensure instanceof works correctly.
  </action>
  <verify>Run `npm run test` - all error tests pass. Run `npm run lint` - no errors.</verify>
  <done>errors.ts exports all error classes and createErrorFromResponse. All instanceof checks work correctly in tests.</done>
</task>

</tasks>

<verification>
Run the complete validation pipeline:

```bash
npm run build && npm run test && npm run lint && npm run typecheck
```

All commands should pass with zero errors.
</verification>

<success_criteria>
- [ ] src/types.ts exists with 4 exported interfaces
- [ ] src/errors.ts exists with 8 error classes and createErrorFromResponse
- [ ] tests/errors.test.ts has comprehensive tests for all error types
- [ ] `npm run test` passes with all new tests green
- [ ] `npm run lint` passes
- [ ] `npm run typecheck` passes
- [ ] Error instanceof checks work (verified by tests)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-infrastructure/02-01-SUMMARY.md`
</output>
