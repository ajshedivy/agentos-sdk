---
phase: 06-file-uploads-and-knowledge
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/resources/knowledge.ts
  - tests/resources/knowledge.test.ts
autonomous: true

must_haves:
  truths:
    - "knowledge.getConfig() retrieves knowledge base configuration"
    - "knowledge.list() returns paginated content list with filtering"
    - "knowledge.upload() accepts file, URL, or text content"
    - "knowledge.search() performs vector search with query and filters"
    - "knowledge.get() retrieves single content by ID"
    - "knowledge.getStatus() retrieves processing status for content"
    - "knowledge.update() updates content properties"
    - "knowledge.delete() removes single content"
    - "knowledge.deleteAll() removes all content (with confirmation)"
  artifacts:
    - path: "src/resources/knowledge.ts"
      provides: "KnowledgeResource class with all knowledge operations"
      exports: ["KnowledgeResource", "UploadOptions", "SearchOptions", "ListKnowledgeOptions"]
    - path: "tests/resources/knowledge.test.ts"
      provides: "Tests for KnowledgeResource"
      min_lines: 150
  key_links:
    - from: "src/resources/knowledge.ts"
      to: "src/utils/files.ts"
      via: "normalizeFileInput for file uploads"
      pattern: "import.*normalizeFileInput.*from.*utils/files"
    - from: "src/resources/knowledge.ts"
      to: "src/client.ts"
      via: "client.request for API calls"
      pattern: "this\\.client\\.request"
---

<objective>
Implement KnowledgeResource class with full knowledge base operations including upload, search, list, and CRUD methods.

Purpose: Enable developers to manage knowledge base content (upload files/URLs/text, search, list, update, delete), fulfilling requirements KNOW-01 through KNOW-04.

Output: Complete KnowledgeResource class in src/resources/knowledge.ts with comprehensive tests.
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-file-uploads-and-knowledge/06-RESEARCH.md
@.planning/phases/06-file-uploads-and-knowledge/06-01-SUMMARY.md

Reference for patterns:
@src/resources/memories.ts (JSON body pattern)
@src/resources/sessions.ts (URLSearchParams pattern)
@src/resources/agents.ts (FormData pattern)
@src/types/files.ts (file input types)
@src/utils/files.ts (normalizeFileInput utility)

OpenAPI knowledge endpoints (from research):
- POST /knowledge/content (upload - multipart/form-data)
- GET /knowledge/content (list - URLSearchParams)
- GET /knowledge/content/{content_id}/status (get status)
- PATCH /knowledge/content/{content_id} (update)
- DELETE /knowledge/content (delete all)
- DELETE /knowledge/content/{content_id} (delete single - inferred)
- POST /knowledge/search (search - JSON body)
- GET /knowledge/config (get config - no params)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KnowledgeResource class structure</name>
  <files>src/resources/knowledge.ts</files>
  <action>
Create src/resources/knowledge.ts with type definitions and class structure:

```typescript
import type { AgentOSClient } from "../client";
import type { components } from "../generated/types";
import type { FileInput } from "../types/files";
import { normalizeFileInput } from "../utils/files";

// Extract types from generated schemas (adjust names based on actual types.ts)
type ContentResponse = components["schemas"]["ContentResponseSchema"];
type ContentStatus = components["schemas"]["ContentStatusSchema"];
type ConfigResponse = components["schemas"]["ConfigResponseSchema"];
type VectorSearchResult = components["schemas"]["VectorSearchResult"];

/**
 * Paginated response for list and search operations
 */
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    page: number;
    limit: number;
    total_pages: number;
    total_count: number;
  };
}

/**
 * Options for uploading content to knowledge base
 */
export interface UploadOptions {
  /** File to upload (one of: file, url, or textContent required) */
  file?: FileInput;
  /** URL to fetch content from (single URL or JSON array of URLs) */
  url?: string;
  /** Raw text content to process */
  textContent?: string;
  /** Content name (auto-generated from file/URL if not provided) */
  name?: string;
  /** Content description */
  description?: string;
  /** JSON metadata object */
  metadata?: Record<string, unknown>;
  /** ID of the reader to use for processing */
  readerId?: string;
  /** Chunking strategy (e.g., 'RecursiveChunker', 'SemanticChunker') */
  chunker?: string;
  /** Chunk size for processing */
  chunkSize?: number;
  /** Chunk overlap for processing */
  chunkOverlap?: number;
  /** Database ID to use for storage */
  dbId?: string;
}

/**
 * Options for listing knowledge content
 */
export interface ListKnowledgeOptions {
  /** Number of entries to return (default: 20) */
  limit?: number;
  /** Page number (default: 1) */
  page?: number;
  /** Field to sort by (default: 'created_at') */
  sortBy?: string;
  /** Sort order: 'asc' or 'desc' (default: 'desc') */
  sortOrder?: 'asc' | 'desc';
  /** Database ID to filter by */
  dbId?: string;
}

/**
 * Options for searching knowledge base
 */
export interface SearchOptions {
  /** Database ID to search in */
  dbId?: string;
  /** Vector database IDs to search in */
  vectorDbIds?: string[];
  /** Search type: 'vector', 'keyword', or 'hybrid' */
  searchType?: 'vector' | 'keyword' | 'hybrid';
  /** Maximum number of results (1-1000) */
  maxResults?: number;
  /** Additional filters for search */
  filters?: Record<string, unknown>;
  /** Pagination: page number */
  page?: number;
  /** Pagination: results per page */
  limit?: number;
}

/**
 * Options for updating content
 */
export interface UpdateContentOptions {
  /** New content name */
  name?: string;
  /** New description */
  description?: string;
  /** Updated metadata (as JSON string) */
  metadata?: Record<string, unknown>;
  /** New reader ID for reprocessing */
  readerId?: string;
  /** Database ID */
  dbId?: string;
}

/**
 * Resource class for knowledge base operations
 *
 * Provides methods to:
 * - Get knowledge configuration
 * - Upload content (files, URLs, text)
 * - List and search content
 * - Update and delete content
 *
 * @example
 * ```typescript
 * const client = new AgentOSClient({ baseUrl: '...' });
 *
 * // Upload a file
 * const content = await client.knowledge.upload({
 *   file: '/path/to/document.pdf',
 *   name: 'My Document',
 * });
 *
 * // Search knowledge base
 * const results = await client.knowledge.search('JavaScript best practices', {
 *   maxResults: 10,
 * });
 * ```
 */
export class KnowledgeResource {
  constructor(private readonly client: AgentOSClient) {}

  // Methods implemented in subsequent sections...
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify type definitions compile.
  </verify>
  <done>KnowledgeResource class structure created with all option type definitions.</done>
</task>

<task type="auto">
  <name>Task 2: Implement knowledge resource methods</name>
  <files>src/resources/knowledge.ts</files>
  <action>
Add all methods to KnowledgeResource class:

```typescript
/**
 * Get knowledge base configuration
 *
 * Returns available readers, chunkers, and processing options.
 */
async getConfig(dbId?: string): Promise<ConfigResponse> {
  const params = new URLSearchParams();
  if (dbId) params.append('db_id', dbId);

  const query = params.toString();
  const path = query ? `/knowledge/config?${query}` : '/knowledge/config';

  return this.client.request<ConfigResponse>('GET', path);
}

/**
 * List all content in knowledge base
 *
 * @param options - Filtering and pagination options
 */
async list(options?: ListKnowledgeOptions): Promise<PaginatedResponse<ContentResponse>> {
  const params = new URLSearchParams();

  if (options?.limit !== undefined) params.append('limit', String(options.limit));
  if (options?.page !== undefined) params.append('page', String(options.page));
  if (options?.sortBy) params.append('sort_by', options.sortBy);
  if (options?.sortOrder) params.append('sort_order', options.sortOrder);
  if (options?.dbId) params.append('db_id', options.dbId);

  const query = params.toString();
  const path = query ? `/knowledge/content?${query}` : '/knowledge/content';

  return this.client.request<PaginatedResponse<ContentResponse>>('GET', path);
}

/**
 * Upload content to knowledge base
 *
 * Supports file uploads, URLs, or raw text content.
 * Content is processed asynchronously - use getStatus() to check progress.
 *
 * @param options - Upload options (one of file, url, or textContent required)
 */
async upload(options: UploadOptions): Promise<ContentResponse> {
  const formData = new FormData();

  // Content source (one of: file, url, textContent)
  if (options.file) {
    formData.append('file', normalizeFileInput(options.file));
  }
  if (options.url) {
    formData.append('url', options.url);
  }
  if (options.textContent) {
    formData.append('text_content', options.textContent);
  }

  // Optional fields
  if (options.name) formData.append('name', options.name);
  if (options.description) formData.append('description', options.description);
  if (options.metadata) formData.append('metadata', JSON.stringify(options.metadata));
  if (options.readerId) formData.append('reader_id', options.readerId);
  if (options.chunker) formData.append('chunker', options.chunker);
  if (options.chunkSize !== undefined) formData.append('chunk_size', String(options.chunkSize));
  if (options.chunkOverlap !== undefined) formData.append('chunk_overlap', String(options.chunkOverlap));

  // Add db_id as query param
  const params = new URLSearchParams();
  if (options.dbId) params.append('db_id', options.dbId);
  const query = params.toString();
  const path = query ? `/knowledge/content?${query}` : '/knowledge/content';

  return this.client.request<ContentResponse>('POST', path, { body: formData });
}

/**
 * Get content by ID
 *
 * @param contentId - Content identifier
 * @param dbId - Optional database ID
 */
async get(contentId: string, dbId?: string): Promise<ContentResponse> {
  const params = new URLSearchParams();
  if (dbId) params.append('db_id', dbId);

  const query = params.toString();
  const basePath = `/knowledge/content/${encodeURIComponent(contentId)}`;
  const path = query ? `${basePath}?${query}` : basePath;

  return this.client.request<ContentResponse>('GET', path);
}

/**
 * Get processing status for content
 *
 * @param contentId - Content identifier
 * @param dbId - Optional database ID
 */
async getStatus(contentId: string, dbId?: string): Promise<ContentStatus> {
  const params = new URLSearchParams();
  if (dbId) params.append('db_id', dbId);

  const query = params.toString();
  const basePath = `/knowledge/content/${encodeURIComponent(contentId)}/status`;
  const path = query ? `${basePath}?${query}` : basePath;

  return this.client.request<ContentStatus>('GET', path);
}

/**
 * Update content properties
 *
 * @param contentId - Content identifier
 * @param options - Properties to update
 */
async update(contentId: string, options: UpdateContentOptions): Promise<ContentResponse> {
  const formData = new FormData();

  if (options.name) formData.append('name', options.name);
  if (options.description) formData.append('description', options.description);
  if (options.metadata) formData.append('metadata', JSON.stringify(options.metadata));
  if (options.readerId) formData.append('reader_id', options.readerId);

  const params = new URLSearchParams();
  if (options.dbId) params.append('db_id', options.dbId);
  const query = params.toString();
  const basePath = `/knowledge/content/${encodeURIComponent(contentId)}`;
  const path = query ? `${basePath}?${query}` : basePath;

  return this.client.request<ContentResponse>('PATCH', path, { body: formData });
}

/**
 * Delete content by ID
 *
 * @param contentId - Content identifier
 * @param dbId - Optional database ID
 */
async delete(contentId: string, dbId?: string): Promise<void> {
  const params = new URLSearchParams();
  if (dbId) params.append('db_id', dbId);

  const query = params.toString();
  const basePath = `/knowledge/content/${encodeURIComponent(contentId)}`;
  const path = query ? `${basePath}?${query}` : basePath;

  await this.client.request<void>('DELETE', path);
}

/**
 * Delete all content from knowledge base
 *
 * WARNING: This is a destructive operation that cannot be undone.
 *
 * @param dbId - Optional database ID to scope deletion
 */
async deleteAll(dbId?: string): Promise<void> {
  const params = new URLSearchParams();
  if (dbId) params.append('db_id', dbId);

  const query = params.toString();
  const path = query ? `/knowledge/content?${query}` : '/knowledge/content';

  await this.client.request<void>('DELETE', path);
}

/**
 * Search knowledge base
 *
 * Performs vector/keyword/hybrid search across content.
 *
 * @param query - Search query text
 * @param options - Search options (filters, pagination, search type)
 */
async search(query: string, options?: SearchOptions): Promise<PaginatedResponse<VectorSearchResult>> {
  const body: Record<string, unknown> = { query };

  if (options?.dbId) body.db_id = options.dbId;
  if (options?.vectorDbIds) body.vector_db_ids = options.vectorDbIds;
  if (options?.searchType) body.search_type = options.searchType;
  if (options?.maxResults) body.max_results = options.maxResults;
  if (options?.filters) body.filters = options.filters;
  if (options?.page !== undefined || options?.limit !== undefined) {
    body.meta = {
      page: options?.page,
      limit: options?.limit,
    };
  }

  return this.client.request<PaginatedResponse<VectorSearchResult>>(
    'POST',
    '/knowledge/search',
    {
      body: JSON.stringify(body),
      headers: { 'Content-Type': 'application/json' },
    }
  );
}
```

Key patterns:
- URLSearchParams for GET query parameters (only append defined values)
- FormData for POST/PATCH with file upload capability
- JSON body for search endpoint (per OpenAPI spec)
- Consistent dbId handling as query parameter where applicable
  </action>
  <verify>
Run `npx tsc --noEmit` to verify all methods compile.
  </verify>
  <done>All KnowledgeResource methods implemented: getConfig, list, upload, get, getStatus, update, delete, deleteAll, search.</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for KnowledgeResource</name>
  <files>tests/resources/knowledge.test.ts</files>
  <action>
Create tests/resources/knowledge.test.ts with comprehensive tests:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { AgentOSClient } from '../../src/client';
import { KnowledgeResource } from '../../src/resources/knowledge';

describe('KnowledgeResource', () => {
  let mockFetch: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    mockFetch = vi.fn();
    vi.stubGlobal('fetch', mockFetch);
  });

  afterEach(() => {
    vi.unstubAllGlobals();
  });

  const createClient = () => new AgentOSClient({ baseUrl: 'https://api.example.com' });

  describe('getConfig', () => {
    it('retrieves knowledge configuration', async () => {
      const configResponse = {
        readers: { pdf: { id: 'pdf', name: 'PDFReader' } },
        chunkers: ['RecursiveChunker'],
      };
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(configResponse),
      });

      const client = createClient();
      const result = await client.knowledge.getConfig();

      expect(mockFetch).toHaveBeenCalledWith(
        'https://api.example.com/knowledge/config',
        expect.any(Object)
      );
      expect(result).toEqual(configResponse);
    });

    it('includes db_id query param when provided', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({}),
      });

      const client = createClient();
      await client.knowledge.getConfig('db-123');

      expect(mockFetch).toHaveBeenCalledWith(
        'https://api.example.com/knowledge/config?db_id=db-123',
        expect.any(Object)
      );
    });
  });

  describe('list', () => {
    it('lists content with default parameters', async () => {
      const listResponse = {
        data: [{ id: 'content-1', name: 'doc.pdf' }],
        meta: { page: 1, limit: 20, total_pages: 1, total_count: 1 },
      };
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(listResponse),
      });

      const client = createClient();
      const result = await client.knowledge.list();

      expect(mockFetch).toHaveBeenCalledWith(
        'https://api.example.com/knowledge/content',
        expect.any(Object)
      );
      expect(result.data).toHaveLength(1);
    });

    it('includes pagination and sorting params', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ data: [], meta: {} }),
      });

      const client = createClient();
      await client.knowledge.list({
        limit: 50,
        page: 2,
        sortBy: 'name',
        sortOrder: 'asc',
        dbId: 'db-123',
      });

      const [url] = mockFetch.mock.calls[0];
      expect(url).toContain('limit=50');
      expect(url).toContain('page=2');
      expect(url).toContain('sort_by=name');
      expect(url).toContain('sort_order=asc');
      expect(url).toContain('db_id=db-123');
    });
  });

  describe('upload', () => {
    it('uploads file with FormData', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ id: 'content-123', status: 'processing' }),
      });

      const client = createClient();
      const buffer = Buffer.from('file content');
      await client.knowledge.upload({
        file: buffer,
        name: 'document.txt',
        description: 'Test document',
      });

      const [url, options] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.example.com/knowledge/content');
      expect(options.body).toBeInstanceOf(FormData);

      const formData = options.body as FormData;
      expect(formData.get('name')).toBe('document.txt');
      expect(formData.get('description')).toBe('Test document');
    });

    it('uploads URL content', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ id: 'content-456' }),
      });

      const client = createClient();
      await client.knowledge.upload({
        url: 'https://example.com/document.pdf',
        name: 'Remote Doc',
      });

      const formData = mockFetch.mock.calls[0][1].body as FormData;
      expect(formData.get('url')).toBe('https://example.com/document.pdf');
    });

    it('uploads text content', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ id: 'content-789' }),
      });

      const client = createClient();
      await client.knowledge.upload({
        textContent: 'This is my knowledge content',
        name: 'Text Note',
      });

      const formData = mockFetch.mock.calls[0][1].body as FormData;
      expect(formData.get('text_content')).toBe('This is my knowledge content');
    });

    it('includes metadata as JSON string', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ id: 'content-1' }),
      });

      const client = createClient();
      await client.knowledge.upload({
        textContent: 'content',
        metadata: { category: 'docs', priority: 1 },
      });

      const formData = mockFetch.mock.calls[0][1].body as FormData;
      expect(formData.get('metadata')).toBe('{"category":"docs","priority":1}');
    });

    it('includes chunker settings', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ id: 'content-1' }),
      });

      const client = createClient();
      await client.knowledge.upload({
        textContent: 'content',
        chunker: 'SemanticChunker',
        chunkSize: 500,
        chunkOverlap: 50,
      });

      const formData = mockFetch.mock.calls[0][1].body as FormData;
      expect(formData.get('chunker')).toBe('SemanticChunker');
      expect(formData.get('chunk_size')).toBe('500');
      expect(formData.get('chunk_overlap')).toBe('50');
    });
  });

  describe('get', () => {
    it('retrieves content by ID', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ id: 'content-123', name: 'doc.pdf' }),
      });

      const client = createClient();
      const result = await client.knowledge.get('content-123');

      expect(mockFetch).toHaveBeenCalledWith(
        'https://api.example.com/knowledge/content/content-123',
        expect.any(Object)
      );
      expect(result.id).toBe('content-123');
    });
  });

  describe('getStatus', () => {
    it('retrieves content processing status', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ status: 'completed', progress: 100 }),
      });

      const client = createClient();
      const result = await client.knowledge.getStatus('content-123');

      expect(mockFetch).toHaveBeenCalledWith(
        'https://api.example.com/knowledge/content/content-123/status',
        expect.any(Object)
      );
      expect(result.status).toBe('completed');
    });
  });

  describe('update', () => {
    it('updates content properties', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ id: 'content-123', name: 'Updated Name' }),
      });

      const client = createClient();
      await client.knowledge.update('content-123', {
        name: 'Updated Name',
        description: 'New description',
      });

      const [url, options] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.example.com/knowledge/content/content-123');
      expect(options.method).toBe('PATCH');

      const formData = options.body as FormData;
      expect(formData.get('name')).toBe('Updated Name');
    });
  });

  describe('delete', () => {
    it('deletes content by ID', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({}),
      });

      const client = createClient();
      await client.knowledge.delete('content-123');

      const [url, options] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.example.com/knowledge/content/content-123');
      expect(options.method).toBe('DELETE');
    });
  });

  describe('deleteAll', () => {
    it('deletes all content', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({}),
      });

      const client = createClient();
      await client.knowledge.deleteAll();

      const [url, options] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.example.com/knowledge/content');
      expect(options.method).toBe('DELETE');
    });

    it('scopes deletion to database ID', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({}),
      });

      const client = createClient();
      await client.knowledge.deleteAll('db-123');

      expect(mockFetch).toHaveBeenCalledWith(
        'https://api.example.com/knowledge/content?db_id=db-123',
        expect.any(Object)
      );
    });
  });

  describe('search', () => {
    it('searches knowledge base with query', async () => {
      const searchResponse = {
        data: [{ id: 'doc-1', content: 'Result content', reranking_score: 0.95 }],
        meta: { page: 1, limit: 20, total_pages: 1, total_count: 1 },
      };
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(searchResponse),
      });

      const client = createClient();
      const result = await client.knowledge.search('JavaScript best practices');

      const [url, options] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.example.com/knowledge/search');
      expect(options.method).toBe('POST');
      expect(options.headers['Content-Type']).toBe('application/json');

      const body = JSON.parse(options.body);
      expect(body.query).toBe('JavaScript best practices');
    });

    it('includes search options', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ data: [], meta: {} }),
      });

      const client = createClient();
      await client.knowledge.search('query', {
        dbId: 'db-123',
        searchType: 'hybrid',
        maxResults: 50,
        filters: { category: 'docs' },
        page: 2,
        limit: 25,
      });

      const body = JSON.parse(mockFetch.mock.calls[0][1].body);
      expect(body.db_id).toBe('db-123');
      expect(body.search_type).toBe('hybrid');
      expect(body.max_results).toBe(50);
      expect(body.filters).toEqual({ category: 'docs' });
      expect(body.meta).toEqual({ page: 2, limit: 25 });
    });
  });
});
```
  </action>
  <verify>
Run `npm test -- tests/resources/knowledge.test.ts` to verify all tests pass.
  </verify>
  <done>Comprehensive tests cover all KnowledgeResource methods: getConfig, list, upload (file/URL/text), get, getStatus, update, delete, deleteAll, and search.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All knowledge tests pass: `npm test -- tests/resources/knowledge.test.ts`
3. All methods use consistent patterns (URLSearchParams, FormData, JSON body)
4. File uploads use normalizeFileInput for cross-platform support
</verification>

<success_criteria>
- KnowledgeResource class implements all 9 methods (getConfig, list, upload, get, getStatus, update, delete, deleteAll, search)
- upload() accepts file, URL, or textContent inputs
- search() sends JSON body per OpenAPI spec
- All methods handle optional dbId parameter
- Tests verify correct URL construction, HTTP methods, and request bodies
</success_criteria>

<output>
After completion, create `.planning/phases/06-file-uploads-and-knowledge/06-03-SUMMARY.md`
</output>
