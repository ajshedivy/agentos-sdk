---
phase: 06-file-uploads-and-knowledge
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - src/client.ts
  - src/index.ts
  - tests/integration.test.ts
autonomous: true

must_haves:
  truths:
    - "client.knowledge namespace provides access to KnowledgeResource"
    - "File input types (Image, Audio, Video, FileType, FileInput) exported from index.ts"
    - "KnowledgeResource and option types exported from index.ts"
    - "normalizeFileInput utility exported for advanced usage"
    - "Integration tests verify knowledge resource is accessible via client"
  artifacts:
    - path: "src/client.ts"
      provides: "AgentOSClient with knowledge property"
      contains: "knowledge: KnowledgeResource"
    - path: "src/index.ts"
      provides: "Public API exports for Phase 6"
      exports: ["KnowledgeResource", "UploadOptions", "SearchOptions", "Image", "Audio", "Video", "FileType"]
  key_links:
    - from: "src/client.ts"
      to: "src/resources/knowledge.ts"
      via: "KnowledgeResource import"
      pattern: "import.*KnowledgeResource.*from.*resources/knowledge"
    - from: "src/index.ts"
      to: "src/types/files.ts"
      via: "file type exports"
      pattern: "export type.*Image.*Audio.*Video"
---

<objective>
Integrate KnowledgeResource into AgentOSClient and export all Phase 6 types from the public API.

Purpose: Complete Phase 6 by wiring the KnowledgeResource into the client and ensuring all new types are properly exported for developer use.

Output: Updated AgentOSClient with knowledge property, updated index.ts with all Phase 6 exports, and integration tests verifying the complete API surface.
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-file-uploads-and-knowledge/06-01-SUMMARY.md
@.planning/phases/06-file-uploads-and-knowledge/06-02-SUMMARY.md
@.planning/phases/06-file-uploads-and-knowledge/06-03-SUMMARY.md

Reference files:
@src/client.ts (current client with 7 resources)
@src/index.ts (current exports)
@src/resources/knowledge.ts (from 06-03)
@src/types/files.ts (from 06-01)
@src/utils/files.ts (from 06-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate KnowledgeResource into AgentOSClient</name>
  <files>src/client.ts</files>
  <action>
Update src/client.ts to include KnowledgeResource:

1. Add import for KnowledgeResource:
```typescript
import { KnowledgeResource } from "./resources/knowledge";
```

2. Add knowledge property declaration in class:
```typescript
export class AgentOSClient {
  readonly version = "0.1.0";
  readonly agents: AgentsResource;
  readonly teams: TeamsResource;
  readonly workflows: WorkflowsResource;
  readonly sessions: SessionsResource;
  readonly memories: MemoriesResource;
  readonly traces: TracesResource;
  readonly metrics: MetricsResource;
  readonly knowledge: KnowledgeResource;  // NEW
  // ...
}
```

3. Initialize knowledge resource in constructor:
```typescript
constructor(options: AgentOSClientOptions) {
  // ... existing code ...

  // Initialize resource namespaces - pass client instance
  this.agents = new AgentsResource(this);
  this.teams = new TeamsResource(this);
  this.workflows = new WorkflowsResource(this);
  this.sessions = new SessionsResource(this);
  this.memories = new MemoriesResource(this);
  this.traces = new TracesResource(this);
  this.metrics = new MetricsResource(this);
  this.knowledge = new KnowledgeResource(this);  // NEW
}
```

Pattern: Follow existing resource integration pattern - import at top, declare readonly property, initialize in constructor passing `this`.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify client compiles with new resource.
  </verify>
  <done>AgentOSClient includes knowledge property initialized with KnowledgeResource instance.</done>
</task>

<task type="auto">
  <name>Task 2: Export all Phase 6 types from index.ts</name>
  <files>src/index.ts</files>
  <action>
Update src/index.ts to export all Phase 6 types and utilities:

1. Add file type exports (after existing type exports):
```typescript
// File input types (Phase 6)
export type {
  FileInput,
  Image,
  Audio,
  Video,
  FileType,
} from "./types/files";
```

2. Add file utility export:
```typescript
// File utilities (Phase 6)
export { normalizeFileInput } from "./utils/files";
```

3. Add KnowledgeResource exports:
```typescript
// Knowledge resource (Phase 6)
export { KnowledgeResource } from "./resources/knowledge";
export type {
  UploadOptions,
  ListKnowledgeOptions,
  SearchOptions,
  UpdateContentOptions,
  PaginatedResponse,
} from "./resources/knowledge";
```

Note: PaginatedResponse might already be defined elsewhere - if so, use a different name or re-export from knowledge.ts only. Check existing codebase for conflicts.

Complete exports section should include:
- File types: FileInput, Image, Audio, Video, FileType
- File utility: normalizeFileInput
- Knowledge class: KnowledgeResource
- Knowledge options: UploadOptions, ListKnowledgeOptions, SearchOptions, UpdateContentOptions
- Note: Updated run option types (RunOptions, StreamRunOptions, etc.) are already exported from their respective resource files
  </action>
  <verify>
Run `npx tsc --noEmit` to verify exports compile. Check that all types are accessible from package root.
  </verify>
  <done>All Phase 6 types exported: file types (Image, Audio, Video, FileType, FileInput), normalizeFileInput utility, KnowledgeResource, and all knowledge option types.</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for Phase 6 features</name>
  <files>tests/integration.test.ts</files>
  <action>
Update tests/integration.test.ts with Phase 6 integration tests:

```typescript
// Add to existing integration test file or create if needed

import {
  AgentOSClient,
  KnowledgeResource,
  // File types
  FileInput,
  Image,
  Audio,
  Video,
  FileType,
  normalizeFileInput,
  // Knowledge options
  UploadOptions,
  ListKnowledgeOptions,
  SearchOptions,
  UpdateContentOptions,
} from '../src';

describe('Phase 6: File Uploads & Knowledge Integration', () => {
  describe('client.knowledge namespace', () => {
    it('provides knowledge resource via client', () => {
      const client = new AgentOSClient({ baseUrl: 'https://api.example.com' });

      expect(client.knowledge).toBeDefined();
      expect(client.knowledge).toBeInstanceOf(KnowledgeResource);
    });

    it('exposes all knowledge methods', () => {
      const client = new AgentOSClient({ baseUrl: 'https://api.example.com' });

      expect(typeof client.knowledge.getConfig).toBe('function');
      expect(typeof client.knowledge.list).toBe('function');
      expect(typeof client.knowledge.upload).toBe('function');
      expect(typeof client.knowledge.get).toBe('function');
      expect(typeof client.knowledge.getStatus).toBe('function');
      expect(typeof client.knowledge.update).toBe('function');
      expect(typeof client.knowledge.delete).toBe('function');
      expect(typeof client.knowledge.deleteAll).toBe('function');
      expect(typeof client.knowledge.search).toBe('function');
    });
  });

  describe('file type exports', () => {
    it('exports file input type aliases', () => {
      // Type-level tests - these just verify the types are exported and usable
      const image: Image = Buffer.from('image');
      const audio: Audio = Buffer.from('audio');
      const video: Video = Buffer.from('video');
      const file: FileType = Buffer.from('file');
      const input: FileInput = Buffer.from('input');

      expect(image).toBeDefined();
      expect(audio).toBeDefined();
      expect(video).toBeDefined();
      expect(file).toBeDefined();
      expect(input).toBeDefined();
    });

    it('exports normalizeFileInput utility', () => {
      expect(typeof normalizeFileInput).toBe('function');

      // Test basic usage
      const buffer = Buffer.from('test');
      const result = normalizeFileInput(buffer);
      expect(result).toBeInstanceOf(Blob);
    });
  });

  describe('knowledge option types', () => {
    it('upload options type is usable', () => {
      const options: UploadOptions = {
        file: Buffer.from('content'),
        name: 'test.txt',
        description: 'Test file',
        metadata: { key: 'value' },
        chunker: 'RecursiveChunker',
        chunkSize: 500,
      };
      expect(options.name).toBe('test.txt');
    });

    it('search options type is usable', () => {
      const options: SearchOptions = {
        dbId: 'db-1',
        searchType: 'hybrid',
        maxResults: 10,
        filters: { category: 'docs' },
      };
      expect(options.searchType).toBe('hybrid');
    });

    it('list options type is usable', () => {
      const options: ListKnowledgeOptions = {
        limit: 50,
        page: 1,
        sortBy: 'created_at',
        sortOrder: 'desc',
      };
      expect(options.limit).toBe(50);
    });
  });

  describe('media parameters in run methods', () => {
    it('agents run accepts media arrays', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ content: 'response' }),
      });
      vi.stubGlobal('fetch', mockFetch);

      const client = new AgentOSClient({ baseUrl: 'https://api.example.com' });

      // Verify types accept media parameters
      await client.agents.run('agent-1', {
        message: 'Process this',
        images: [Buffer.from('img')],
        audio: [Buffer.from('aud')],
        videos: [Buffer.from('vid')],
        files: [Buffer.from('file')],
      });

      const formData = mockFetch.mock.calls[0][1].body as FormData;
      expect(formData.getAll('images')).toHaveLength(1);
      expect(formData.getAll('audio')).toHaveLength(1);
      expect(formData.getAll('videos')).toHaveLength(1);
      expect(formData.getAll('files')).toHaveLength(1);

      vi.unstubAllGlobals();
    });

    it('teams run accepts media arrays', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ content: 'response' }),
      });
      vi.stubGlobal('fetch', mockFetch);

      const client = new AgentOSClient({ baseUrl: 'https://api.example.com' });

      await client.teams.run('team-1', {
        message: 'Process this',
        images: [Buffer.from('img')],
      });

      const formData = mockFetch.mock.calls[0][1].body as FormData;
      expect(formData.getAll('images')).toHaveLength(1);

      vi.unstubAllGlobals();
    });

    it('workflows run accepts media arrays', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ content: 'response' }),
      });
      vi.stubGlobal('fetch', mockFetch);

      const client = new AgentOSClient({ baseUrl: 'https://api.example.com' });

      await client.workflows.run('workflow-1', {
        message: 'Process this',
        images: [Buffer.from('img')],
      });

      const formData = mockFetch.mock.calls[0][1].body as FormData;
      expect(formData.getAll('images')).toHaveLength(1);

      vi.unstubAllGlobals();
    });
  });
});
```
  </action>
  <verify>
Run `npm test -- tests/integration.test.ts` to verify all integration tests pass. Then run full test suite: `npm test`.
  </verify>
  <done>Integration tests verify: client.knowledge namespace works, all file types are exported and usable, normalizeFileInput is exported, knowledge option types are usable, and media parameters work in agents/teams/workflows run methods.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All tests pass: `npm test`
3. client.knowledge is accessible and functional
4. All Phase 6 types are exported from package root
5. Integration tests verify complete API surface
</verification>

<success_criteria>
- AgentOSClient has 8 resource namespaces (agents, teams, workflows, sessions, memories, traces, metrics, knowledge)
- All file input types exported: Image, Audio, Video, FileType, FileInput
- normalizeFileInput utility exported for advanced usage
- KnowledgeResource and all option types exported
- Updated RunOptions with media support are accessible via existing resource exports
- All tests pass including new integration tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-file-uploads-and-knowledge/06-04-SUMMARY.md`
</output>
