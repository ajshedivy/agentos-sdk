---
phase: 06-file-uploads-and-knowledge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/files.ts
  - src/utils/files.ts
autonomous: true

must_haves:
  truths:
    - "FileInput union type accepts string paths, Buffer, ReadStream, Blob, and File"
    - "Image, Audio, Video, and File type aliases defined for semantic clarity"
    - "normalizeFileInput helper converts paths to streams in Node.js"
    - "normalizeFileInput converts Buffer to Blob for FormData compatibility"
  artifacts:
    - path: "src/types/files.ts"
      provides: "File input type definitions (FileInput, Image, Audio, Video)"
      exports: ["FileInput", "Image", "Audio", "Video", "FileType"]
    - path: "src/utils/files.ts"
      provides: "File normalization utility"
      exports: ["normalizeFileInput"]
  key_links:
    - from: "src/types/files.ts"
      to: "global types"
      via: "union type for flexible file inputs"
      pattern: "string \\| Buffer \\| ReadStream \\| Blob \\| File"
---

<objective>
Create file input type definitions and normalization utilities for multipart file uploads.

Purpose: Enable flexible file inputs (paths, buffers, streams, blobs) that work across Node.js and browser environments, following OpenAI SDK patterns.

Output: File type definitions in src/types/files.ts and normalizeFileInput helper in src/utils/files.ts that convert various inputs to FormData-compatible formats.
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-file-uploads-and-knowledge/06-RESEARCH.md

Reference for patterns:
@src/types.ts (existing type definitions pattern)
@src/resources/agents.ts (FormData usage pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file input type definitions</name>
  <files>src/types/files.ts</files>
  <action>
Create src/types/files.ts with file input types following OpenAI SDK pattern:

```typescript
import type { ReadStream } from 'fs';

/**
 * Flexible file input type supporting multiple formats.
 *
 * - string: File path (Node.js only, converted to ReadStream)
 * - Buffer: In-memory binary data (converted to Blob)
 * - ReadStream: Node.js file stream (passed directly)
 * - Blob: Browser Blob or Node.js Blob
 * - File: Browser File object
 */
export type FileInput = string | Buffer | ReadStream | Blob | File;

/**
 * Image file input for agent/team/workflow runs.
 * Alias for FileInput with semantic meaning.
 */
export type Image = FileInput;

/**
 * Audio file input for agent/team/workflow runs.
 * Alias for FileInput with semantic meaning.
 */
export type Audio = FileInput;

/**
 * Video file input for agent/team/workflow runs.
 * Alias for FileInput with semantic meaning.
 */
export type Video = FileInput;

/**
 * Generic file input for agent/team/workflow runs.
 * Alias for FileInput with semantic meaning.
 *
 * Note: Named FileType to avoid collision with global File type.
 */
export type FileType = FileInput;
```

Key decisions:
- Use ReadStream from 'fs' for Node.js streams (type-only import, no runtime dependency)
- Create semantic aliases (Image, Audio, Video, FileType) for self-documenting API
- Name generic file type as FileType to avoid collision with browser File global
- Document each type with JSDoc explaining supported formats
  </action>
  <verify>
Run `npx tsc --noEmit` to verify type definitions compile without errors.
  </verify>
  <done>File input types defined with union type supporting string | Buffer | ReadStream | Blob | File, plus semantic aliases Image, Audio, Video, FileType.</done>
</task>

<task type="auto">
  <name>Task 2: Create file normalization utility</name>
  <files>src/utils/files.ts</files>
  <action>
Create src/utils/files.ts with normalizeFileInput helper:

```typescript
import * as fs from 'fs';
import type { ReadStream } from 'fs';
import type { FileInput } from '../types/files';

/**
 * Normalize file input to a format suitable for FormData.
 *
 * Handles:
 * - string paths: Converted to ReadStream (Node.js only)
 * - Buffer: Converted to Blob for FormData compatibility
 * - ReadStream/Blob/File: Passed through unchanged
 *
 * @param input - File input in any supported format
 * @param filename - Optional filename for the normalized file
 * @returns Normalized file suitable for FormData.append()
 * @throws Error if string path used in non-Node.js environment
 *
 * @example Node.js with file path
 * ```typescript
 * const normalized = normalizeFileInput('/path/to/image.png');
 * formData.append('images', normalized);
 * ```
 *
 * @example Buffer input
 * ```typescript
 * const buffer = fs.readFileSync('image.png');
 * const normalized = normalizeFileInput(buffer, 'image.png');
 * formData.append('images', normalized);
 * ```
 */
export function normalizeFileInput(
  input: FileInput,
  filename?: string
): Blob | ReadStream | File {
  // String path -> ReadStream (Node.js only)
  if (typeof input === 'string') {
    // Check if fs module is available (Node.js environment)
    if (typeof fs.createReadStream === 'function') {
      return fs.createReadStream(input);
    }
    throw new Error(
      'File paths are only supported in Node.js environments. ' +
      'In browser environments, use File or Blob instead.'
    );
  }

  // Buffer -> Blob (for FormData compatibility)
  if (Buffer.isBuffer(input)) {
    // Create Blob with optional filename via File constructor if available
    if (filename && typeof File !== 'undefined') {
      return new File([input], filename);
    }
    return new Blob([input]);
  }

  // ReadStream, Blob, or File - pass through unchanged
  return input;
}
```

Key decisions:
- Runtime check for fs.createReadStream to handle browser/Node.js environments
- Convert Buffer to Blob (not File) by default since File constructor may not exist in all environments
- Support optional filename parameter for Buffer -> File conversion when File constructor exists
- Clear error message when path used in browser environment
- Import fs as namespace to allow conditional runtime checks
  </action>
  <verify>
Run `npx tsc --noEmit` to verify utility compiles. Create a quick test:

```bash
echo "import { normalizeFileInput } from './src/utils/files'; console.log(typeof normalizeFileInput);" > /tmp/test-files.ts && npx tsc /tmp/test-files.ts --noEmit --esModuleInterop --skipLibCheck
```
  </verify>
  <done>normalizeFileInput helper created that converts string paths to ReadStream, Buffer to Blob, and passes through ReadStream/Blob/File unchanged.</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for file utilities</name>
  <files>tests/utils/files.test.ts</files>
  <action>
Create tests/utils/files.test.ts with comprehensive tests:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as fs from 'fs';
import { normalizeFileInput } from '../../src/utils/files';

describe('normalizeFileInput', () => {
  describe('string path input (Node.js)', () => {
    it('converts file path to ReadStream', () => {
      const mockStream = { pipe: vi.fn() } as unknown as fs.ReadStream;
      vi.spyOn(fs, 'createReadStream').mockReturnValue(mockStream);

      const result = normalizeFileInput('/path/to/file.txt');

      expect(fs.createReadStream).toHaveBeenCalledWith('/path/to/file.txt');
      expect(result).toBe(mockStream);
    });
  });

  describe('Buffer input', () => {
    it('converts Buffer to Blob', () => {
      const buffer = Buffer.from('test content');

      const result = normalizeFileInput(buffer);

      expect(result).toBeInstanceOf(Blob);
    });

    it('converts Buffer to File when filename provided and File exists', () => {
      const buffer = Buffer.from('test content');

      const result = normalizeFileInput(buffer, 'test.txt');

      // In Node.js 20+, File constructor exists
      if (typeof File !== 'undefined') {
        expect(result).toBeInstanceOf(File);
        expect((result as File).name).toBe('test.txt');
      } else {
        expect(result).toBeInstanceOf(Blob);
      }
    });
  });

  describe('Blob input', () => {
    it('passes Blob through unchanged', () => {
      const blob = new Blob(['test content']);

      const result = normalizeFileInput(blob);

      expect(result).toBe(blob);
    });
  });

  describe('File input', () => {
    it('passes File through unchanged', () => {
      // Skip if File constructor not available
      if (typeof File === 'undefined') {
        return;
      }

      const file = new File(['test content'], 'test.txt');

      const result = normalizeFileInput(file);

      expect(result).toBe(file);
    });
  });

  describe('ReadStream input', () => {
    it('passes ReadStream through unchanged', () => {
      const mockStream = { pipe: vi.fn() } as unknown as fs.ReadStream;

      const result = normalizeFileInput(mockStream as unknown as fs.ReadStream);

      expect(result).toBe(mockStream);
    });
  });
});
```

Key test coverage:
- String path conversion to ReadStream
- Buffer conversion to Blob
- Buffer conversion to File with filename (when available)
- Pass-through for Blob, File, and ReadStream inputs
  </action>
  <verify>
Run `npm test -- tests/utils/files.test.ts` to verify all tests pass.
  </verify>
  <done>Tests cover all file input type conversions: string path to ReadStream, Buffer to Blob/File, and pass-through for Blob/File/ReadStream.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All file utility tests pass: `npm test -- tests/utils/files.test.ts`
3. Type definitions are properly exported and usable
</verification>

<success_criteria>
- FileInput union type defined supporting string | Buffer | ReadStream | Blob | File
- Semantic aliases (Image, Audio, Video, FileType) defined for API clarity
- normalizeFileInput helper converts all input types to FormData-compatible formats
- Tests cover all conversion paths with mocked fs for Node.js streams
</success_criteria>

<output>
After completion, create `.planning/phases/06-file-uploads-and-knowledge/06-01-SUMMARY.md`
</output>
