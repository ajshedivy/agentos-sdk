---
phase: 04-streaming-support
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/streaming/stream.ts
  - src/streaming/index.ts
  - tests/streaming/stream.test.ts
autonomous: true

must_haves:
  truths:
    - "User can consume stream via for await...of syntax"
    - "User can consume stream via .on() event handlers"
    - "User can abort stream at any time via .abort() method"
    - "Stream throws clear error when consumed twice"
  artifacts:
    - path: "src/streaming/stream.ts"
      provides: "AgentStream class with dual interfaces"
      exports: ["AgentStream"]
      min_lines: 80
    - path: "tests/streaming/stream.test.ts"
      provides: "Comprehensive stream class tests"
      min_lines: 100
  key_links:
    - from: "src/streaming/stream.ts"
      to: "src/streaming/parser.ts"
      via: "uses parseSSEResponse for iteration"
      pattern: "parseSSEResponse"
    - from: "src/streaming/stream.ts"
      to: "src/streaming/events.ts"
      via: "implements AsyncIterable<AgentRunEvent>"
      pattern: "AsyncIterable.*AgentRunEvent"
---

<objective>
Create AgentStream class with dual async iterator and event emitter interfaces.

Purpose: Provides the core streaming abstraction that AgentsResource.runStream() will return.
Output: AgentStream class implementing AsyncIterable<AgentRunEvent> with .on() event handlers and .abort() cancellation.
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-streaming-support/04-RESEARCH.md
@.planning/phases/04-streaming-support/04-01-SUMMARY.md
@src/streaming/events.ts
@src/streaming/parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AgentStream class with AsyncIterable interface</name>
  <files>
    src/streaming/stream.ts
  </files>
  <action>
Create `src/streaming/stream.ts` implementing the AgentStream class.

**Class requirements:**
1. Implements `AsyncIterable<AgentRunEvent>` via `[Symbol.asyncIterator]()`
2. Tracks consumption state to prevent double iteration
3. Exposes AbortController for cancellation
4. Factory method `fromSSEResponse()` to create from Response

**Implementation (following Anthropic SDK pattern from research):**
```typescript
import type { AgentRunEvent } from './events';
import { parseSSEResponse } from './parser';

/**
 * Stream of agent run events with dual consumption patterns.
 *
 * Supports two ways to consume events:
 * 1. Async iteration: `for await (const event of stream) { ... }`
 * 2. Event handlers: `stream.on('RunContent', handler).start()`
 *
 * @example Async iteration
 * ```typescript
 * const stream = await client.agents.runStream('agent-id', { message: 'Hi' });
 * for await (const event of stream) {
 *   if (event.event === 'RunContent') {
 *     console.log(event.content);
 *   }
 * }
 * ```
 *
 * @example Event handlers
 * ```typescript
 * const stream = await client.agents.runStream('agent-id', { message: 'Hi' });
 * await stream
 *   .on('RunContent', e => console.log(e.content))
 *   .on('RunCompleted', e => console.log('Done:', e.metrics))
 *   .start();
 * ```
 */
export class AgentStream implements AsyncIterable<AgentRunEvent> {
  readonly controller: AbortController;
  private consumed = false;
  private listeners = new Map<string, Set<(event: AgentRunEvent) => void>>();

  /**
   * @internal Use AgentStream.fromSSEResponse() to create instances
   */
  constructor(
    private iteratorFn: () => AsyncGenerator<AgentRunEvent>,
    controller: AbortController
  ) {
    this.controller = controller;
  }

  /**
   * Create AgentStream from SSE Response.
   *
   * @param response - Fetch Response with text/event-stream body
   * @param controller - AbortController for stream cancellation
   * @returns AgentStream instance
   */
  static fromSSEResponse(
    response: Response,
    controller: AbortController
  ): AgentStream {
    return new AgentStream(
      () => parseSSEResponse(response, controller),
      controller
    );
  }

  /**
   * AsyncIterable implementation for for-await-of loops.
   * Can only be iterated once. Throws if already consumed.
   */
  [Symbol.asyncIterator](): AsyncIterator<AgentRunEvent> {
    if (this.consumed) {
      throw new Error(
        'Stream has already been consumed. ' +
        'AgentStream can only be iterated once.'
      );
    }
    this.consumed = true;
    return this.iteratorFn();
  }

  /**
   * Register event handler for specific event type.
   * Chainable - returns this for fluent API.
   *
   * @param eventType - Event type to listen for (e.g., 'RunContent')
   * @param handler - Callback function for matching events
   */
  on<K extends AgentRunEvent['event']>(
    eventType: K,
    handler: (event: Extract<AgentRunEvent, { event: K }>) => void
  ): this {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, new Set());
    }
    this.listeners.get(eventType)!.add(handler as (event: AgentRunEvent) => void);
    return this;
  }

  /**
   * Start consuming stream and dispatching events to handlers.
   * Must be called after registering handlers with .on().
   *
   * @returns Promise that resolves when stream completes
   */
  async start(): Promise<void> {
    for await (const event of this) {
      this.emit(event);
    }
  }

  /**
   * Abort the stream. Signals cancellation to the underlying fetch.
   */
  abort(): void {
    this.controller.abort();
  }

  /**
   * Check if stream has been aborted.
   */
  get aborted(): boolean {
    return this.controller.signal.aborted;
  }

  /**
   * Dispatch event to registered handlers.
   */
  private emit(event: AgentRunEvent): void {
    const handlers = this.listeners.get(event.event);
    if (handlers) {
      for (const handler of handlers) {
        try {
          handler(event);
        } catch (error) {
          // Log but don't rethrow - don't break iteration on handler error
          console.error('Event handler error:', error);
        }
      }
    }
  }
}
```
  </action>
  <verify>
- `npx tsc --noEmit` passes with no errors
- AgentStream exports from stream.ts
- Class implements AsyncIterable<AgentRunEvent>
  </verify>
  <done>AgentStream class created with AsyncIterable and event emitter dual interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Update streaming exports and add comprehensive tests</name>
  <files>
    src/streaming/index.ts
    tests/streaming/stream.test.ts
  </files>
  <action>
1. Update `src/streaming/index.ts` to export AgentStream:
```typescript
export * from './events';
export { parseSSEResponse } from './parser';
export { AgentStream } from './stream';
```

2. Create `tests/streaming/stream.test.ts` with comprehensive tests:

**Test categories:**

**a) AsyncIterable interface:**
- Iterates through all events in order
- Throws "already consumed" error on second iteration
- Handles empty stream
- Yields correct event types

**b) Event emitter interface (.on() + .start()):**
- Calls registered handler for matching events
- Multiple handlers for same event type
- Handler receives correctly typed event
- Non-matching events don't trigger handlers
- Handler errors don't break iteration

**c) Cancellation:**
- abort() sets controller.signal.aborted = true
- Iteration stops when aborted
- aborted getter reflects controller state

**d) Factory method:**
- fromSSEResponse creates valid stream
- Throws on null response body

**Test helpers:**
```typescript
// Create mock Response with SSE body
function createMockSSEResponse(events: Array<{ event: string; data: object }>): Response {
  const encoder = new TextEncoder();
  const sseText = events
    .map(e => `event: ${e.event}\ndata: ${JSON.stringify(e.data)}\n\n`)
    .join('');

  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(encoder.encode(sseText));
      controller.close();
    }
  });

  return new Response(stream, {
    headers: { 'Content-Type': 'text/event-stream' }
  });
}

// Sample events for tests
const sampleEvents = [
  { event: 'RunStarted', data: { created_at: 1000, run_id: 'run-1', session_id: 'sess-1', agent_id: 'agent-1', agent_name: 'Test Agent', model: 'gpt-4', model_provider: 'openai' } },
  { event: 'RunContent', data: { created_at: 1001, run_id: 'run-1', content: 'Hello', content_type: 'text/plain' } },
  { event: 'RunCompleted', data: { created_at: 1002, run_id: 'run-1', session_id: 'sess-1', agent_id: 'agent-1', agent_name: 'Test Agent', content: 'Hello!', content_type: 'text/plain' } }
];
```
  </action>
  <verify>
- `npm test tests/streaming/stream.test.ts` passes all tests
- Tests cover both iteration and event emitter patterns
- Tests cover cancellation and error cases
  </verify>
  <done>AgentStream exported and fully tested with both consumption patterns</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- `npm test tests/streaming` passes all tests (events, parser, stream)
- `npm run lint` passes
- AgentStream importable: `import { AgentStream } from './streaming'`
</verification>

<success_criteria>
1. AgentStream class implements AsyncIterable<AgentRunEvent>
2. Stream supports for await...of iteration (consumed once, throws on second)
3. Stream supports .on('eventType', handler).start() event emitter pattern
4. Stream has .abort() and .aborted for cancellation
5. AgentStream.fromSSEResponse() factory creates stream from Response
6. All tests pass with coverage of both patterns and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/04-streaming-support/04-02-SUMMARY.md`
</output>
