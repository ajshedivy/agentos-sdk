---
phase: 04-streaming-support
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/client.ts
  - src/resources/agents.ts
  - src/index.ts
  - tests/resources/agents.test.ts
  - tests/client.test.ts
  - tests/index.test.ts
autonomous: true

must_haves:
  truths:
    - "User can call client.agents.runStream() and get AgentStream"
    - "User can call client.agents.continue() with streaming support"
    - "User can call client.agents.cancel() to stop a running agent"
    - "Streaming types are exported from public API"
  artifacts:
    - path: "src/resources/agents.ts"
      provides: "AgentsResource with runStream, continue, cancel methods"
      exports: ["AgentsResource", "RunOptions", "StreamRunOptions", "ContinueOptions"]
    - path: "src/index.ts"
      provides: "Public exports including streaming types"
      exports: ["AgentStream", "AgentRunEvent"]
  key_links:
    - from: "src/resources/agents.ts"
      to: "src/streaming/stream.ts"
      via: "returns AgentStream from runStream()"
      pattern: "AgentStream\\.fromSSEResponse"
    - from: "src/resources/agents.ts"
      to: "src/client.ts"
      via: "calls client.requestStream()"
      pattern: "this\\.client\\.requestStream"
    - from: "src/client.ts"
      to: "src/streaming/stream.ts"
      via: "requestStream returns Response for streaming"
      pattern: "requestStream"
---

<objective>
Add streaming methods to AgentsResource (runStream, continue, cancel) and update public exports.

Purpose: Completes Phase 4 by enabling users to stream agent responses with the AgentStream API.
Output: Full streaming API on AgentsResource, requestStream method on client, all types exported.
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-streaming-support/04-RESEARCH.md
@.planning/phases/04-streaming-support/04-02-SUMMARY.md
@src/client.ts
@src/resources/agents.ts
@src/streaming/stream.ts
@src/streaming/events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add requestStream method to AgentOSClient</name>
  <files>
    src/client.ts
    tests/client.test.ts
  </files>
  <action>
Add a `requestStream()` method to AgentOSClient that returns the raw Response for streaming consumption.

**Why separate method:** Regular `request()` returns parsed JSON. Streaming needs the raw Response body to parse SSE events.

**Implementation:**
```typescript
/**
 * Make a streaming request that returns raw Response.
 *
 * Unlike request() which parses JSON, this returns the Response
 * for SSE streaming. Does NOT use retry logic - streaming requests
 * are not safely retryable.
 *
 * @internal - Used by resource classes for streaming endpoints
 */
async requestStream(
  method: RequestOptions['method'],
  path: string,
  options: Omit<RequestOptions, 'method'> = {}
): Promise<Response> {
  const url = `${this.baseUrl}${path}`;
  let headers = this.buildHeaders(options.headers);

  // Remove Content-Type for FormData - fetch auto-sets with boundary
  if (options.body instanceof FormData) {
    const { 'Content-Type': _, ...headersWithoutContentType } = headers;
    headers = headersWithoutContentType;
  }

  // Add Accept header for SSE
  headers['Accept'] = 'text/event-stream';

  const fetchOptions: globalThis.RequestInit = {
    method,
    headers,
    body: options.body instanceof FormData ? options.body : undefined,
    signal: options.signal,
  };

  const response = await fetch(url, fetchOptions);

  if (!response.ok) {
    // Import parseErrorBody and createErrorFromResponse to handle errors
    // Use dynamic import or move error parsing to separate utility
    const message = await response.text();
    const requestId = response.headers.get('x-request-id') ?? undefined;
    throw createErrorFromResponse(
      response.status,
      message,
      requestId,
      this.extractHeaders(response.headers)
    );
  }

  return response;
}

// Helper method to extract headers (move existing logic)
private extractHeaders(headers: Headers): Record<string, string> {
  const result: Record<string, string> = {};
  headers.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
```

**Note:** Import `createErrorFromResponse` from `./errors` at top of file.

**Tests to add in tests/client.test.ts:**
- requestStream returns Response object
- requestStream sets Accept: text/event-stream header
- requestStream removes Content-Type for FormData
- requestStream throws on non-2xx status
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npm test tests/client.test.ts` passes
- requestStream method exists on AgentOSClient
  </verify>
  <done>AgentOSClient has requestStream() method for streaming endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Add streaming methods to AgentsResource</name>
  <files>
    src/resources/agents.ts
    tests/resources/agents.test.ts
  </files>
  <action>
Add `runStream()`, `continue()`, and `cancel()` methods to AgentsResource.

**1. Add StreamRunOptions and ContinueOptions types:**
```typescript
/**
 * Options for streaming agent run
 */
export interface StreamRunOptions {
  /** The message to send to the agent */
  message: string;
  /** Optional session ID for conversation continuity */
  sessionId?: string;
  /** Optional user ID for user context */
  userId?: string;
}

/**
 * Options for continuing a paused agent run
 */
export interface ContinueOptions {
  /** JSON string containing array of tool execution results */
  tools: string;
  /** Optional session ID */
  sessionId?: string;
  /** Optional user ID */
  userId?: string;
  /** Whether to stream the response (default: true) */
  stream?: boolean;
}
```

**2. Add runStream() method:**
```typescript
/**
 * Run an agent with streaming response.
 *
 * Returns an AgentStream that can be consumed via:
 * - Async iteration: `for await (const event of stream) { ... }`
 * - Event handlers: `stream.on('RunContent', handler).start()`
 *
 * @param agentId - The unique identifier for the agent
 * @param options - Run configuration including message and optional context
 * @returns AgentStream for consuming events
 *
 * @example Async iteration
 * ```typescript
 * const stream = await client.agents.runStream('agent-id', {
 *   message: 'Hello!',
 * });
 * for await (const event of stream) {
 *   if (event.event === 'RunContent') {
 *     process.stdout.write(event.content);
 *   }
 * }
 * ```
 */
async runStream(agentId: string, options: StreamRunOptions): Promise<AgentStream> {
  const formData = new FormData();
  formData.append('message', options.message);
  formData.append('stream', 'true');

  if (options.sessionId) {
    formData.append('session_id', options.sessionId);
  }
  if (options.userId) {
    formData.append('user_id', options.userId);
  }

  const controller = new AbortController();
  const response = await this.client.requestStream(
    'POST',
    `/agents/${encodeURIComponent(agentId)}/runs`,
    { body: formData, signal: controller.signal }
  );

  return AgentStream.fromSSEResponse(response, controller);
}
```

**3. Add continue() method:**
```typescript
/**
 * Continue a paused agent run with tool results.
 *
 * @param agentId - The agent identifier
 * @param runId - The run identifier to continue
 * @param options - Continue options including tool results
 * @returns AgentStream if streaming, otherwise the run result
 */
async continue(
  agentId: string,
  runId: string,
  options: ContinueOptions
): Promise<AgentStream | unknown> {
  const formData = new FormData();
  formData.append('tools', options.tools);
  formData.append('stream', String(options.stream ?? true));

  if (options.sessionId) {
    formData.append('session_id', options.sessionId);
  }
  if (options.userId) {
    formData.append('user_id', options.userId);
  }

  const path = `/agents/${encodeURIComponent(agentId)}/runs/${encodeURIComponent(runId)}/continue`;

  if (options.stream !== false) {
    const controller = new AbortController();
    const response = await this.client.requestStream(
      'POST',
      path,
      { body: formData, signal: controller.signal }
    );
    return AgentStream.fromSSEResponse(response, controller);
  } else {
    return this.client.request<unknown>('POST', path, { body: formData });
  }
}
```

**4. Add cancel() method:**
```typescript
/**
 * Cancel a running agent.
 *
 * @param agentId - The agent identifier
 * @param runId - The run identifier to cancel
 */
async cancel(agentId: string, runId: string): Promise<void> {
  await this.client.request<void>(
    'POST',
    `/agents/${encodeURIComponent(agentId)}/runs/${encodeURIComponent(runId)}/cancel`
  );
}
```

**5. Add imports at top:**
```typescript
import { AgentStream } from '../streaming';
```

**Tests to add:**
- runStream returns AgentStream instance
- runStream builds correct FormData with stream=true
- continue returns AgentStream when stream=true (default)
- continue returns result when stream=false
- cancel makes POST request to cancel endpoint
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npm test tests/resources/agents.test.ts` passes
- AgentsResource has runStream, continue, cancel methods
  </verify>
  <done>AgentsResource has complete streaming API (runStream, continue, cancel)</done>
</task>

<task type="auto">
  <name>Task 3: Update public exports and finalize tests</name>
  <files>
    src/index.ts
    tests/index.test.ts
  </files>
  <action>
1. Update `src/index.ts` to export streaming types:

```typescript
// Streaming
export { AgentStream } from './streaming';
export type {
  AgentRunEvent,
  RunStartedEvent,
  RunContentEvent,
  RunCompletedEvent,
  MemoryUpdateStartedEvent,
  MemoryUpdateCompletedEvent,
} from './streaming';

// Update resource exports to include new types
export type { RunOptions, StreamRunOptions, ContinueOptions } from './resources/agents';
```

2. Update `tests/index.test.ts` to verify new exports:
- AgentStream class exported
- All event types exported
- StreamRunOptions type exported
- ContinueOptions type exported

**Test structure:**
```typescript
describe('streaming exports', () => {
  it('exports AgentStream class', () => {
    expect(AgentStream).toBeDefined();
    expect(typeof AgentStream).toBe('function');
  });

  it('exports streaming option types', () => {
    // Type-level test - if these compile, types are exported
    const streamOpts: StreamRunOptions = { message: 'test' };
    const continueOpts: ContinueOptions = { tools: '[]' };
    expect(streamOpts.message).toBe('test');
    expect(continueOpts.tools).toBe('[]');
  });
});
```

3. Run full test suite to ensure no regressions:
```bash
npm test
npm run lint
npm run build
```
  </action>
  <verify>
- `npm run build` succeeds
- `npm test` passes all tests
- `npm run lint` passes
- All streaming types importable from main entry point
  </verify>
  <done>Complete streaming API exported from SDK entry point</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- `npm test` passes (all existing + new streaming tests)
- `npm run lint` passes
- Streaming works end-to-end with mock SSE responses in tests
- Public API includes: AgentStream, AgentRunEvent types, runStream(), continue(), cancel()
</verification>

<success_criteria>
1. AgentOSClient has requestStream() method for streaming requests
2. AgentsResource.runStream() returns AgentStream
3. AgentsResource.continue() supports streaming (default) and non-streaming
4. AgentsResource.cancel() cancels running agent
5. All streaming types exported from SDK entry point (AgentStream, events, options)
6. Tests cover all new methods and integration with mock SSE responses
7. All builds and tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-streaming-support/04-03-SUMMARY.md`
</output>
