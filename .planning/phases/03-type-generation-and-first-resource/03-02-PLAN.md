---
phase: 03-type-generation-and-first-resource
plan: 02
type: execute
wave: 3
depends_on: ["03-03"]
files_modified:
  - src/resources/agents.ts
  - src/client.ts
  - src/index.ts
  - tests/resources/agents.test.ts
  - tests/client.test.ts
  - tests/index.test.ts
autonomous: true

must_haves:
  truths:
    - "User can list all agents with type-safe response"
    - "User can get agent details by ID with type-safe response"
    - "User can run agent (non-streaming) and receive typed result"
    - "Client class exposes agents namespace with resource methods"
    - "User can call client.agents.list() to list agents"
  artifacts:
    - path: "src/resources/agents.ts"
      provides: "AgentsResource class with list, get, run methods"
      exports: ["AgentsResource"]
      min_lines: 50
    - path: "src/client.ts"
      provides: "AgentOSClient with agents property"
      contains: "this.agents = new AgentsResource"
    - path: "src/index.ts"
      provides: "Exports for agents resource and types"
      exports: ["AgentsResource"]
    - path: "tests/resources/agents.test.ts"
      provides: "Tests for agents resource methods"
      min_lines: 100
  key_links:
    - from: "src/resources/agents.ts"
      to: "src/generated/types.ts"
      via: "import type"
      pattern: "import.*from.*generated/types"
    - from: "src/resources/agents.ts"
      to: "src/client.ts"
      via: "client.request() method"
      pattern: "this\\.client\\.request"
    - from: "src/client.ts"
      to: "src/resources/agents.ts"
      via: "import and instantiation"
      pattern: "import.*AgentsResource"
---

<objective>
Create the AgentsResource class and integrate it into AgentOSClient.

Purpose: Establish the resource class pattern that will be replicated for teams, workflows, sessions, and other resources. This is the first real API resource implementation. Also integrate into client so users can access via client.agents.list().

Output: AgentsResource class with three methods (list, get, run), integrated into AgentOSClient, with complete public exports.
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-generation-and-first-resource/03-CONTEXT.md
@.planning/phases/03-type-generation-and-first-resource/03-01-SUMMARY.md
@.planning/phases/03-type-generation-and-first-resource/03-03-SUMMARY.md

# Existing code
@src/client.ts
@src/index.ts
@src/http.ts
@src/types.ts
@src/generated/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AgentsResource class</name>
  <files>src/resources/agents.ts</files>
  <action>
Create src/resources directory and agents.ts file.

**IMPORTANT**: Per user decision, AgentsResource receives the client instance and uses client.request() instead of importing requestWithRetry directly. This requires Plan 03-03 to change client.request() from private to protected first.

Design the AgentsResource class:

```typescript
import type { components } from '../generated/types';
import type { AgentOSClient } from '../client';

// Extract types from generated schemas
type AgentResponse = components['schemas']['AgentResponse'];
type AgentRunRequest = components['schemas']['Body_create_agent_run'];

export interface RunOptions {
  message: string;
  sessionId?: string;
  userId?: string;
  stream?: false; // Only non-streaming in Phase 3
}

export class AgentsResource {
  constructor(private readonly client: AgentOSClient) {}

  /**
   * List all agents
   * GET /agents
   */
  async list(): Promise<AgentResponse[]> {
    return this.client.request<AgentResponse[]>('GET', '/agents');
  }

  /**
   * Get agent details by ID
   * GET /agents/{agent_id}
   */
  async get(agentId: string): Promise<AgentResponse> {
    return this.client.request<AgentResponse>(
      'GET',
      `/agents/${encodeURIComponent(agentId)}`
    );
  }

  /**
   * Run an agent (non-streaming)
   * POST /agents/{agent_id}/runs
   */
  async run(agentId: string, options: RunOptions): Promise<unknown> {
    // Build FormData for multipart request
    const formData = new FormData();
    formData.append('message', options.message);
    formData.append('stream', 'false'); // Force non-streaming

    if (options.sessionId) {
      formData.append('session_id', options.sessionId);
    }
    if (options.userId) {
      formData.append('user_id', options.userId);
    }

    // Pass FormData as body, client.request handles Content-Type removal for FormData
    return this.client.request<unknown>(
      'POST',
      `/agents/${encodeURIComponent(agentId)}/runs`,
      { body: formData }
    );
  }
}
```

Key implementation notes:
- AgentsResource receives client instance, NOT a config object
- All requests go through client.request() - uses client's baseUrl, headers, timeout, retry config
- Use generated types for AgentResponse
- Run method uses FormData (multipart) as per API spec
- DO NOT set Content-Type for FormData - client.request should handle this (see 03-03)
- URL-encode agentId to handle special characters
- stream: false enforced for Phase 3 (streaming is Phase 4)
- Return type for run() is unknown for now - actual response type varies
  </action>
  <verify>
- src/resources/agents.ts exists
- File exports AgentsResource class
- Class has list(), get(), run() methods
- `npm run typecheck` passes
  </verify>
  <done>AgentsResource class implemented with list, get, run methods using generated types</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for AgentsResource</name>
  <files>tests/resources/agents.test.ts</files>
  <action>
Create tests/resources directory and agents.test.ts file.

Test all three methods using a mock client. Since AgentsResource now receives a client instance, we mock client.request() rather than global fetch.

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { AgentsResource } from '../../src/resources/agents';
import { AgentOSClient } from '../../src/client';

describe('AgentsResource', () => {
  let resource: AgentsResource;
  let mockClient: AgentOSClient;
  let requestSpy: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    // Create a real client, then spy on its request method
    mockClient = new AgentOSClient({
      baseUrl: 'https://api.example.com',
      apiKey: 'test-key',
    });
    requestSpy = vi.fn();
    // Mock the protected request method
    (mockClient as any).request = requestSpy;

    resource = new AgentsResource(mockClient);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('list()', () => {
    it('returns array of agents', async () => {
      const mockAgents = [
        { id: 'agent-1', name: 'Agent One' },
        { id: 'agent-2', name: 'Agent Two' },
      ];
      requestSpy.mockResolvedValueOnce(mockAgents);

      const result = await resource.list();

      expect(result).toEqual(mockAgents);
      expect(requestSpy).toHaveBeenCalledWith('GET', '/agents');
    });

    it('propagates errors from client.request', async () => {
      requestSpy.mockRejectedValueOnce(new Error('Unauthorized'));

      await expect(resource.list()).rejects.toThrow('Unauthorized');
    });
  });

  describe('get()', () => {
    it('returns agent by ID', async () => {
      const mockAgent = { id: 'agent-1', name: 'Agent One', model: { name: 'gpt-4' } };
      requestSpy.mockResolvedValueOnce(mockAgent);

      const result = await resource.get('agent-1');

      expect(result).toEqual(mockAgent);
      expect(requestSpy).toHaveBeenCalledWith('GET', '/agents/agent-1');
    });

    it('URL-encodes agent ID', async () => {
      requestSpy.mockResolvedValueOnce({ id: 'agent/special' });

      await resource.get('agent/special');

      expect(requestSpy).toHaveBeenCalledWith('GET', '/agents/agent%2Fspecial');
    });

    it('propagates NotFoundError from client', async () => {
      requestSpy.mockRejectedValueOnce(new Error('Not found'));

      await expect(resource.get('nonexistent')).rejects.toThrow('Not found');
    });
  });

  describe('run()', () => {
    it('sends message via client.request with FormData', async () => {
      requestSpy.mockResolvedValueOnce({ run_id: 'run-123', content: 'Hello!' });

      const result = await resource.run('agent-1', { message: 'Hi there' });

      expect(result).toEqual({ run_id: 'run-123', content: 'Hello!' });
      expect(requestSpy).toHaveBeenCalledWith(
        'POST',
        '/agents/agent-1/runs',
        expect.objectContaining({ body: expect.any(FormData) })
      );

      // Verify FormData contents
      const callArgs = requestSpy.mock.calls[0];
      const formData = callArgs[2].body as FormData;
      expect(formData.get('message')).toBe('Hi there');
      expect(formData.get('stream')).toBe('false');
    });

    it('includes session_id and user_id when provided', async () => {
      requestSpy.mockResolvedValueOnce({ run_id: 'run-123' });

      await resource.run('agent-1', {
        message: 'Hi',
        sessionId: 'session-456',
        userId: 'user-789',
      });

      const callArgs = requestSpy.mock.calls[0];
      const formData = callArgs[2].body as FormData;
      expect(formData.get('session_id')).toBe('session-456');
      expect(formData.get('user_id')).toBe('user-789');
    });

    it('forces stream to false', async () => {
      requestSpy.mockResolvedValueOnce({});

      await resource.run('agent-1', { message: 'Hi' });

      const callArgs = requestSpy.mock.calls[0];
      const formData = callArgs[2].body as FormData;
      expect(formData.get('stream')).toBe('false');
    });
  });
});
```

Tests cover:
- list(): successful response, error propagation from client
- get(): successful response, URL encoding, error propagation
- run(): FormData construction, optional params, stream=false
- All tests verify that client.request() is called with correct arguments
  </action>
  <verify>
- tests/resources/agents.test.ts exists
- `npm test` passes with new tests
- Coverage includes list, get, run methods
  </verify>
  <done>AgentsResource fully tested with mocked fetch calls</done>
</task>

<task type="auto">
  <name>Task 3: Add agents property to AgentOSClient</name>
  <files>src/client.ts</files>
  <action>
Modify AgentOSClient to include an `agents` property that exposes AgentsResource methods.

**IMPORTANT**: Per user decision, AgentsResource receives the client instance (`this`), NOT a config object. This allows AgentsResource to call `client.request()` directly.

Changes to src/client.ts:

1. Import AgentsResource:
```typescript
import { AgentsResource } from './resources/agents';
```

2. Add readonly agents property to the class:
```typescript
readonly agents: AgentsResource;
```

3. In constructor, instantiate AgentsResource with `this` (the client instance):
```typescript
// Initialize resource namespaces - pass client instance
this.agents = new AgentsResource(this);
```

Full updated class structure:
```typescript
import { requestWithRetry } from "./http";
import { AgentsResource } from "./resources/agents";
import type {
  AgentOSClientOptions,
  HealthStatus,
  OSConfig,
  RequestOptions,
} from "./types";

export class AgentOSClient {
  readonly version = "0.1.0";
  readonly agents: AgentsResource;

  private readonly baseUrl: string;
  private readonly apiKey?: string;
  private readonly timeout: number;
  private readonly maxRetries: number;
  private readonly defaultHeaders: Record<string, string>;

  constructor(options: AgentOSClientOptions) {
    if (!options.baseUrl) {
      throw new Error("baseUrl is required");
    }

    this.baseUrl = options.baseUrl.replace(/\/$/, "");
    this.apiKey = options.apiKey;
    this.timeout = options.timeout ?? 30000;
    this.maxRetries = options.maxRetries ?? 2;
    this.defaultHeaders = {
      "Content-Type": "application/json",
      "User-Agent": `agentos-sdk/${this.version}`,
      ...options.headers,
    };

    // Initialize resource namespaces - pass client instance
    this.agents = new AgentsResource(this);
  }

  // ... existing methods (getConfig, health, request, buildHeaders) unchanged
}
```

This approach:
- Passes client instance to AgentsResource (not config)
- AgentsResource calls `client.request()` for all API requests
- No duplication of baseUrl, headers, timeout, retry logic
- Consistent architecture for future resources (TeamsResource, etc.)
  </action>
  <verify>
- src/client.ts imports AgentsResource
- AgentOSClient has readonly `agents` property
- Constructor passes `this` to AgentsResource
- `npm run typecheck` passes
  </verify>
  <done>AgentOSClient has agents property providing access to AgentsResource methods</done>
</task>

<task type="auto">
  <name>Task 4: Update index.ts exports</name>
  <files>src/index.ts</files>
  <action>
Update src/index.ts to export:
1. AgentsResource class (for advanced users who want to instantiate directly)
2. Generated types (for type annotations)
3. RunOptions type from agents resource

Add these exports to the existing index.ts:

```typescript
// Resource classes
export { AgentsResource } from './resources/agents';
export type { RunOptions } from './resources/agents';

// Generated types (re-export useful types)
export type { components, paths } from './generated/types';
```

Keep all existing exports (AgentOSClient, errors, types, VERSION).

The final index.ts should export:
- AgentOSClient (main entry point)
- AgentsResource (for direct use if needed)
- Error classes (APIError, BadRequestError, etc.)
- Configuration types (AgentOSClientOptions, RequestOptions, RunOptions)
- Generated types namespace (components, paths)
- VERSION constant
  </action>
  <verify>
- src/index.ts exports AgentsResource
- src/index.ts exports generated types
- `npm run typecheck` passes
- `npm run build` succeeds
  </verify>
  <done>All public APIs exported from index.ts including AgentsResource and generated types</done>
</task>

<task type="auto">
  <name>Task 5: Update tests for client integration</name>
  <files>tests/client.test.ts, tests/index.test.ts</files>
  <action>
Update existing test files to cover the new agents property.

In tests/client.test.ts, add tests:
```typescript
describe('agents property', () => {
  it('exposes AgentsResource instance', () => {
    const client = new AgentOSClient({ baseUrl: 'https://api.example.com' });
    expect(client.agents).toBeDefined();
    expect(typeof client.agents.list).toBe('function');
    expect(typeof client.agents.get).toBe('function');
    expect(typeof client.agents.run).toBe('function');
  });

  it('agents resource uses client.request for API calls', async () => {
    const fetchSpy = vi.spyOn(globalThis, 'fetch').mockResolvedValueOnce(
      new Response(JSON.stringify([]), { status: 200 })
    );

    const client = new AgentOSClient({
      baseUrl: 'https://api.example.com',
      apiKey: 'test-key',
    });

    await client.agents.list();

    expect(fetchSpy).toHaveBeenCalledWith(
      'https://api.example.com/agents',
      expect.objectContaining({
        headers: expect.objectContaining({
          Authorization: 'Bearer test-key',
        }),
      })
    );

    fetchSpy.mockRestore();
  });
});
```

In tests/index.test.ts, add export verification:
```typescript
it('exports AgentsResource', () => {
  expect(AgentsResource).toBeDefined();
  expect(typeof AgentsResource).toBe('function');
});

it('exports generated types namespace', () => {
  // Type-level check - if this compiles, exports work
  // Runtime: just verify the import doesn't throw
  expect(true).toBe(true);
});
```

Update imports in test files to include new exports.
  </action>
  <verify>
- tests/client.test.ts has agents property tests
- tests/index.test.ts verifies AgentsResource export
- `npm test` passes
- All existing tests still pass
  </verify>
  <done>Client and index tests updated to cover agents integration</done>
</task>

</tasks>

<verification>
1. src/resources/agents.ts exports AgentsResource class
2. AgentsResource has list(), get(), run() methods
3. Methods use generated types from src/generated/types.ts
4. client.agents property exists and is AgentsResource instance
5. client.agents.list(), get(), run() methods work end-to-end
6. AgentsResource exported from index.ts
7. Generated types exported from index.ts
8. `npm run typecheck` passes
9. `npm test` passes with all tests
10. `npm run build` succeeds
11. `npm run lint` passes
</verification>

<success_criteria>
- AgentsResource class exists with list, get, run methods
- Methods properly call client.request() with correct arguments
- Run method uses FormData without manual Content-Type
- All methods are typed with generated types
- AgentOSClient has `agents` property
- Users can call client.agents.list(), client.agents.get(id), client.agents.run(id, opts)
- All types and classes properly exported
- Full test coverage for agents resource and client integration
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-generation-and-first-resource/03-02-SUMMARY.md`
</output>
