---
phase: 03-type-generation-and-first-resource
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/resources/agents.ts
  - tests/resources/agents.test.ts
autonomous: true

must_haves:
  truths:
    - "User can list all agents with type-safe response"
    - "User can get agent details by ID with type-safe response"
    - "User can run agent (non-streaming) and receive typed result"
  artifacts:
    - path: "src/resources/agents.ts"
      provides: "AgentsResource class with list, get, run methods"
      exports: ["AgentsResource"]
      min_lines: 50
    - path: "tests/resources/agents.test.ts"
      provides: "Tests for agents resource methods"
      min_lines: 100
  key_links:
    - from: "src/resources/agents.ts"
      to: "src/generated/types.ts"
      via: "import type"
      pattern: "import.*from.*generated/types"
    - from: "src/resources/agents.ts"
      to: "src/http.ts"
      via: "requestWithRetry function"
      pattern: "requestWithRetry"
---

<objective>
Create the AgentsResource class implementing list(), get(), and run() methods using generated types.

Purpose: Establish the resource class pattern that will be replicated for teams, workflows, sessions, and other resources. This is the first real API resource implementation.

Output: AgentsResource class with three methods (list, get, run) that make typed API calls.
</objective>

<execution_context>
@/Users/adamshedivy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamshedivy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-generation-and-first-resource/03-CONTEXT.md
@.planning/phases/03-type-generation-and-first-resource/03-01-SUMMARY.md

# Existing code
@src/client.ts
@src/http.ts
@src/types.ts
@src/generated/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AgentsResource class</name>
  <files>src/resources/agents.ts</files>
  <action>
Create src/resources directory and agents.ts file.

Design the AgentsResource class:

```typescript
import type { components } from '../generated/types';
import { requestWithRetry } from '../http';

// Extract types from generated schemas
type AgentResponse = components['schemas']['AgentResponse'];
type AgentRunRequest = components['schemas']['Body_create_agent_run'];

export interface AgentsResourceConfig {
  baseUrl: string;
  headers: Record<string, string>;
  timeout: number;
  maxRetries: number;
}

export interface RunOptions {
  message: string;
  sessionId?: string;
  userId?: string;
  stream?: false; // Only non-streaming in Phase 3
}

export class AgentsResource {
  constructor(private readonly config: AgentsResourceConfig) {}

  /**
   * List all agents
   * GET /agents
   */
  async list(): Promise<AgentResponse[]> {
    return requestWithRetry<AgentResponse[]>(
      `${this.config.baseUrl}/agents`,
      { method: 'GET', headers: this.config.headers },
      this.config.maxRetries,
      this.config.timeout
    );
  }

  /**
   * Get agent details by ID
   * GET /agents/{agent_id}
   */
  async get(agentId: string): Promise<AgentResponse> {
    return requestWithRetry<AgentResponse>(
      `${this.config.baseUrl}/agents/${encodeURIComponent(agentId)}`,
      { method: 'GET', headers: this.config.headers },
      this.config.maxRetries,
      this.config.timeout
    );
  }

  /**
   * Run an agent (non-streaming)
   * POST /agents/{agent_id}/runs
   */
  async run(agentId: string, options: RunOptions): Promise<unknown> {
    // Build FormData for multipart request
    const formData = new FormData();
    formData.append('message', options.message);
    formData.append('stream', 'false'); // Force non-streaming

    if (options.sessionId) {
      formData.append('session_id', options.sessionId);
    }
    if (options.userId) {
      formData.append('user_id', options.userId);
    }

    // Don't set Content-Type header - fetch will set it with boundary
    const headers = { ...this.config.headers };
    delete headers['Content-Type'];

    return requestWithRetry<unknown>(
      `${this.config.baseUrl}/agents/${encodeURIComponent(agentId)}/runs`,
      {
        method: 'POST',
        headers,
        body: formData,
      },
      this.config.maxRetries,
      this.config.timeout
    );
  }
}
```

Key implementation notes:
- Use generated types for AgentResponse
- Run method uses FormData (multipart) as per API spec
- DO NOT set Content-Type for FormData - fetch auto-sets with boundary (per STATE.md concern)
- URL-encode agentId to handle special characters
- stream: false enforced for Phase 3 (streaming is Phase 4)
- Return type for run() is unknown for now - actual response type varies
  </action>
  <verify>
- src/resources/agents.ts exists
- File exports AgentsResource class
- Class has list(), get(), run() methods
- `npm run typecheck` passes
  </verify>
  <done>AgentsResource class implemented with list, get, run methods using generated types</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for AgentsResource</name>
  <files>tests/resources/agents.test.ts</files>
  <action>
Create tests/resources directory and agents.test.ts file.

Test all three methods with mocked fetch:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { AgentsResource } from '../../src/resources/agents';

describe('AgentsResource', () => {
  const mockConfig = {
    baseUrl: 'https://api.example.com',
    headers: { 'Content-Type': 'application/json', Authorization: 'Bearer test-key' },
    timeout: 5000,
    maxRetries: 0, // No retries in tests
  };

  let resource: AgentsResource;
  let fetchSpy: ReturnType<typeof vi.spyOn>;

  beforeEach(() => {
    resource = new AgentsResource(mockConfig);
    fetchSpy = vi.spyOn(globalThis, 'fetch');
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('list()', () => {
    it('returns array of agents', async () => {
      const mockAgents = [
        { id: 'agent-1', name: 'Agent One' },
        { id: 'agent-2', name: 'Agent Two' },
      ];
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify(mockAgents), { status: 200 })
      );

      const result = await resource.list();

      expect(result).toEqual(mockAgents);
      expect(fetchSpy).toHaveBeenCalledWith(
        'https://api.example.com/agents',
        expect.objectContaining({ method: 'GET' })
      );
    });

    it('throws on API error', async () => {
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 })
      );

      await expect(resource.list()).rejects.toThrow();
    });
  });

  describe('get()', () => {
    it('returns agent by ID', async () => {
      const mockAgent = { id: 'agent-1', name: 'Agent One', model: { name: 'gpt-4' } };
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify(mockAgent), { status: 200 })
      );

      const result = await resource.get('agent-1');

      expect(result).toEqual(mockAgent);
      expect(fetchSpy).toHaveBeenCalledWith(
        'https://api.example.com/agents/agent-1',
        expect.objectContaining({ method: 'GET' })
      );
    });

    it('URL-encodes agent ID', async () => {
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify({ id: 'agent/special' }), { status: 200 })
      );

      await resource.get('agent/special');

      expect(fetchSpy).toHaveBeenCalledWith(
        'https://api.example.com/agents/agent%2Fspecial',
        expect.any(Object)
      );
    });

    it('throws NotFoundError for missing agent', async () => {
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify({ detail: 'Not found' }), { status: 404 })
      );

      await expect(resource.get('nonexistent')).rejects.toThrow();
    });
  });

  describe('run()', () => {
    it('sends message with FormData', async () => {
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify({ run_id: 'run-123', content: 'Hello!' }), { status: 200 })
      );

      const result = await resource.run('agent-1', { message: 'Hi there' });

      expect(result).toEqual({ run_id: 'run-123', content: 'Hello!' });

      const [url, options] = fetchSpy.mock.calls[0];
      expect(url).toBe('https://api.example.com/agents/agent-1/runs');
      expect(options.method).toBe('POST');
      expect(options.body).toBeInstanceOf(FormData);
    });

    it('includes session_id and user_id when provided', async () => {
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify({ run_id: 'run-123' }), { status: 200 })
      );

      await resource.run('agent-1', {
        message: 'Hi',
        sessionId: 'session-456',
        userId: 'user-789',
      });

      const [, options] = fetchSpy.mock.calls[0];
      const formData = options.body as FormData;
      expect(formData.get('session_id')).toBe('session-456');
      expect(formData.get('user_id')).toBe('user-789');
    });

    it('removes Content-Type header for FormData', async () => {
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify({}), { status: 200 })
      );

      await resource.run('agent-1', { message: 'Hi' });

      const [, options] = fetchSpy.mock.calls[0];
      expect(options.headers['Content-Type']).toBeUndefined();
    });

    it('forces stream to false', async () => {
      fetchSpy.mockResolvedValueOnce(
        new Response(JSON.stringify({}), { status: 200 })
      );

      await resource.run('agent-1', { message: 'Hi' });

      const [, options] = fetchSpy.mock.calls[0];
      const formData = options.body as FormData;
      expect(formData.get('stream')).toBe('false');
    });
  });
});
```

Tests cover:
- list(): successful response, error handling
- get(): successful response, URL encoding, 404 handling
- run(): FormData construction, optional params, Content-Type removal, stream=false
  </action>
  <verify>
- tests/resources/agents.test.ts exists
- `npm test` passes with new tests
- Coverage includes list, get, run methods
  </verify>
  <done>AgentsResource fully tested with mocked fetch calls</done>
</task>

</tasks>

<verification>
1. src/resources/agents.ts exports AgentsResource class
2. AgentsResource has list(), get(), run() methods
3. Methods use generated types from src/generated/types.ts
4. `npm run typecheck` passes
5. `npm test` passes with agents resource tests
6. `npm run lint` passes
</verification>

<success_criteria>
- AgentsResource class exists with list, get, run methods
- Methods properly call the correct API endpoints
- Run method uses FormData without manual Content-Type
- All methods are typed with generated types
- Comprehensive test coverage for all methods
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-generation-and-first-resource/03-02-SUMMARY.md`
</output>
